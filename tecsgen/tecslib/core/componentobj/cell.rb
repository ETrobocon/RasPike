# -*- coding: utf-8 -*-
#
#  TECS Generator
#      Generator for TOPPERS Embedded Component System
#  
#   Copyright (C) 2008-2021 by TOPPERS Project
#--
#   上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
#   ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
#   変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
#   (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
#       権表示，この利用条件および下記の無保証規定が，そのままの形でソー
#       スコード中に含まれていること．
#   (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
#       用できる形で再配布する場合には，再配布に伴うドキュメント（利用
#       者マニュアルなど）に，上記の著作権表示，この利用条件および下記
#       の無保証規定を掲載すること．
#   (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
#       用できない形で再配布する場合には，次のいずれかの条件を満たすこ
#       と．
#     (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
#         作権表示，この利用条件および下記の無保証規定を掲載すること．
#     (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
#         報告すること．
#   (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
#       害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
#       また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
#       由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
#       免責すること．
#  
#   本ソフトウェアは，無保証で提供されているものである．上記著作権者お
#   よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
#   に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
#   アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
#   の責任を負わない．
#  
#   $Id: cell.rb 3266 2023-01-03 07:32:40Z okuma-top $
#++

class Cell < NSBDNode # < Nestable
# @name:: Symbol : composite celltype の内側のインスタンスでは外のセル
# @global_name:: Symbol : C で使える名前（namespace を含む）
# @local_name:: str : cell celltype name { ... } の name
# @celltype:: Celltype | CompositeCelltype
# @join_list:: NamedList
# @reverse_join_list:: NamedList
# @b_defined:: definition flag (false if only prototype )
# @b_prototype:: bool:  prototype specified in current parsing cell. (@b_defined is used to determine whether definition done)
# @b_duplicate:: bool:  definition duplicate
# @b_checked::   bool:  set_definition_join が済んでいる場合 true
# @require_joined_list:: {cp_name=>true}:  set_require_join が済んでいる呼び口は true
# @f_ref:: refercenced from others
# @entry_array_max_subscript:: { @port=>Integer } : 受け口配列の配列添数の最大値（添数無し受け口配列対応）
# @plugin::     Plugin: avialble if cell is generated by plugin generated cdl code.
# @referenced_port_list:: { Port => Integer } : 受け口の参照数
#                                               すべての意味解析(through, composite展開)が終わった後に設定する
#                                               逆require ポートに対して複数の結合がないかチェックする
# @generate:: [ Symbol, String, Plugin ]  = [ PluginName, option, Plugin ] Plugin は生成後に追加される (generate指定子)
# @generate_list:: [ [ Symbol, String, Plugin ], ... ]   generate 指定と generate 文で追加された generate の両方
# @b_post_code_generated:: Bool: true if generated in tmp_plugin_post_code.cdl
#
# composite のためインスタンス変数
# @in_composite:: bool : true if in composite celltype
# @compositecelltypejoin_list:: NamedList : item= CompositeCelltypeJoin ( if @in_composite )
# @f_cloned:: bool : true if cloned (instantiate of composite consist cell)
# @my_clone:: Cell : Composite cell で in_composite = true の場合のみ有効（直前の clone を一時記憶）
# @cell_list:: Cell[local_name] : Composite cell で clone した後のリスト cell_list
# @cell_list2:: [ Cell ] : Composite cell で clone した後のリスト cell_list
#                          @cell_list2 は composite 内での出現順  
#
# region のためのインスタンス変数
# @region:: Region (属するregion)
#
# allocator のためのインスタンス変数
# @alloc_list::  [ [ NORMAL_ALLOC, ep_name, func_name, param_name, expr ], ... ]
#   受け口側のアロケータへの結合を記憶。以下のメソッドで追加される
#      set_specifier … cell 定義時にアロケータ指定されている場合
#      create_relay_allocator_join … リレーアロケータの場合
#
# ID のためのインスタンス変数（optimize.rb にて設定）
# @id:: Integer : コード生成直前に設定  (プロトタイプ宣言の場合は -1 のまま放置)
# @id_specified::Integer : 指定された id
#
# restrict のためのインスタンス変数
# @restrict_list::{ entry_name => { func_name, [ region_path_str, ... ] } }
# @restrict_list2::{ entry_name => { func_name, [ domain_root_region, ... ] } }
# @b_restrict_referenced::Bool: restrict_list が参照れた
#
# 受け口 through のためのインスタンス変数
# @ep_through_list [ [ep_name, PluginName, "option"], ... ]
=begin
# Cell クラスは、以下のものを扱う
# 1)普通のセル
# 2)composite セルタイプのセル
# 3)composite セルタイプの内側のセル (@in_composite)   # composite の内側の composite セルタイプのセルもある
#
# 2) は CellOfComposite クラスとして分けたほうがよいかもしれない
#    expand (composite セルの展開) は CellOfComposite にのみ必要なメソッドである
#    get_real_cell, get_real_port など @celltype.instance_of?( CompositeCelltype ) の判定がなくすっきりする
#    ただ、分離しても、メンテナンスすべき範囲が切り離されてしまい、忘れやすくなる問題とのトレードオフかも
#
# 3) は CellInCompoiste クラスとして分けたほうがよいかもしれない
#    @in_composite で判定している処理を切り離せる (上記 2) よりも分離は容易ではない)
#    clone_for_composite は CellInCompoiste にのみ必要なメソッドである
#    ただし、clone 後に Cell, CellOfComposite に変化する必要があるので、clone ではなく new する実装に変更する必要がある
#
=end

  include PluginModule

  @@nest_stack_index = -1
  @@nest_stack = []
  @@current_object = nil

  # 定義されたすべてのセル（出現順. namespace に影響されない）
  @@cell_list = []     # composite の内部のセルを含まない
  @@cell_list2 = []    # composite の内部のセルを含む (元のセルを含む)
                       # 意味解析後 make_cell_list2 にて設定される

  def self.push
    @@nest_stack_index += 1
    @@nest_stack[ @@nest_stack_index ] = @@current_object
    @@current_object = nil
  end

  def self.pop
    @@current_object = @@nest_stack[ @@nest_stack_index ]
    @@nest_stack_index -= 1
    if @@nest_stack_index < -1 then
      raise "TooManyRestore"
    end
  end

  def initialize( ct_path, in_composite = false )
    super()
    @region = Region.get_current

    # celltype のplugin/存在をチェック
    object = Namespace.find( ct_path )    #1
    if object == nil then
      # mikan celltype の名前が不完全 "::ct1ct2" になる
      cdl_error( "S1027 \'$1\' celltype not found" , ct_path.get_path_str )
    elsif ! object.instance_of?( Celltype ) && ! object.instance_of?( CompositeCelltype ) then
      # mikan celltype の名前が不完全
      cdl_error( "S1028 \'$1\' not celltype" , ct_path.get_path_str )
    else
      @celltype = object
    end

    @in_composite = in_composite
    if @in_composite then
      @compositecelltypejoin_list = NamedList.new( nil, "in cell '#{@name}'" )
      @plugin = nil
    else
      @compositecelltypejoin_list = nil
      @plugin = Generator.get_plugin
    end

    @@current_object = self
    @b_defined = false
    @b_prototype = false
    @f_ref     = false
    @f_cloned  = false
    @alloc_list = []
    @id = -1
    @id_specified = nil
    @b_duplicate = false
    @b_checked = false
    @require_joined_list = {}
    @entry_array_max_subscript = {}
    @referenced_port_list = {}
    @restrict_list = {}
    @restrict_list2 = {}
    @b_restrict_referenced = false
    @b_post_code_generated = false
    @ep_through_list = []

    @cell_list = {}
    @cell_list2 = []
  end

  def self.set_name( name )
    @@current_object.set_name( name )
  end

  def set_name( name )

    @name = name
    @local_name = name
    if "#{Namespace.get_global_name}" != "" then
      @global_name = :"#{Namespace.get_global_name}_#{name}"
    else
      @global_name = name
    end

    # この時点ではプロトタイプか、定義か分らないが、自己参照のために登録
    # set_f_def で再度登録しなおす
    # Celltype への登録は、end_of_parse で行う
    if @in_composite then
      cell_prev = CompositeCelltype.find( name )
      if cell_prev == nil then
        CompositeCelltype.new_cell_in_composite( self )
      end
    else
      # cell_prev = Namespace.find( [ name ] )   # 親まで捜しにいく
      cell_prev = Namespace.get_current.find( name )
      if cell_prev == nil then
        Namespace.new_cell( self )
        set_namespace_path # @NamespacePath の設定
      end
    end

    if cell_prev then
      if ! cell_prev.instance_of?( Cell ) then
        cdl_error( "S1029 $1 mismatch with previous one" , name )
        # celltype が一致しているか ?
      elsif get_celltype != cell_prev.get_celltype then
        cdl_error( "S1030 $1: celltype mismatch with previous one" , name )
      else
        # region が一致しているか?
        if ! cell_prev.get_region.equal? get_region then
          cdl_error( "S1031 $1 region \'$2\' mismatch  with previous one \'$3\'" , name, @region.get_name, cell_prev.get_region.get_name )
        end

        @@current_object = cell_prev
        # この時点では、まだプロトタイプ宣言か定義か分らない
        # 以前が定義であって、今回も定義の場合、重複エラーである
      end
    end

    @join_list = NamedList.new( nil, "in cell '#{@name}'" )
    @reverse_join_list = nil

    # debug
    dbgPrint "Cell new_cell: #{@global_name} #{@in_composite} #{self}\n"

    # 内部アロケータを @alloc_list に追加
    if @celltype.instance_of? CompositeCelltype then
      @celltype.get_internal_allocator_list.each{ |cell, cp_internal_name, port_name, fd_name, par_name, ext_alloc_ent|
        nsp = NamespacePath.new( @name, false )
        rhs = Expression.new( [:OP_DOT, [:IDENTIFIER, nsp], Token.new( ext_alloc_ent.to_s.to_sym, nil, nil, nil ) ] )  #1 構文解析段階なので locale 不要

        @alloc_list << [:NORMAL_ALLOC,port_name,nil,fd_name,par_name,rhs]
# print "add alloc_list: #{port_name}.#{fd_name}.#{par_name}=#{rhs.to_s}\n"
      }
    end
  end

  #=== Cell# cell の定義
  # 本体(join)の定義の直前に呼び出される
  def self.new_def
    @@current_object.new_def
  end

  #=== Cell# cell の定義
  # 本体(join)の定義の直前に呼び出される
  # このメソッドは cell tCelltype Cell { };  '{', '}' の部分がある場合に呼出される
  def new_def
    set_specifier_list( Generator.get_statement_specifier )

    # prototype 指定子ないか
    if ! @b_prototype then
      # 二重定義のチェック
      if @b_defined == true then
        cdl_error( "S1032 $1: duplicate cell" , @name )
        dbgPrint "previous: #{@prev_locale[0]}: line #{@prev_locale[1]} '#{@name}' defined here\n"

        # セルの重複定義エラーの処置
        # 前の定義は捨てる
        @join_list = NamedList.new( nil, "in cell '#{@name}'" )
      end

      @b_defined = true
      @prev_locale = @locale
    end
  end

  def self.new_join( join, b_regular = false )
    @@current_object.new_join( join, b_regular )
  end

  #===  Cell# 新しい結合をチェック
  # STAGE:   P
  #
  #join::  Join : 新しい結合
  #b_regular:: bool : 通常の場所 (bnf.y.rb)からならば true, それ以外(allocator, require) では false
  def new_join( join, b_regular = false )
    join.set_owner self

    # composite の新文法対応．
    # composite の中のセルで、attribute の定義である場合
    # cell 内の attr_ext = composite.attr; 構文を処理
    if @in_composite then
      if @celltype then
        if @celltype.find(join.get_name).instance_of?( Decl ) then # mikan a::b で指定されていたものがエラーにならないかも
          rhs = join.get_rhs
          if rhs.instance_of? Expression then
            ele = rhs.get_elements
            if( ele[0]==:IDENTIFIER )then    #  attr = attr_ext （右辺単項）か？ #1
              if( CompositeCelltype.has_attribute?(ele[1].get_name ) )then    # mikan a::b.ePort がエラーにならないかも
                ident = ele[1].get_name   # 右辺は attribute．
              else
                # 右辺は attribute にないのであれば、定数のはず
                # 定数は下へ渡す (cell の join にする)
                ident = nil
              end
            else
              if join.get_rhs.eval_const2(nil) == nil then   # 定数式ではないか？
                # 右辺が、単一のシンボルでない場合、現状は扱えない
                cdl_error( "S1033 rhs expression is not supported. Only attribute is permitted on current version."  )
                return
              else
                # 定数は下へ渡す (cell の join にする)
                ident = nil
              end
            end

            if ident then
              # attr = attr; のような参照はエラー (a = composite.a とする必要がある)
              if @celltype.find( ident ) then
                cdl_error( "S1034 $1 : cannot refer to $2\'s attribute here. Use \'composite.$3\' to refer to composite celltype\'s" , ident, @celltype.get_name, ident )
              end
            end
          elsif rhs.instance_of? Array then
            if rhs[0] == :COMPOSITE then   # 右辺は composite.attr の形式
              ident = rhs[1].to_sym
            else
              ident = nil    # 右辺は { 10, -10 } の形式
            end
          else
            ident = nil      # 右辺は C_EXP の形式
          end

          # ident が見つかった（右辺は単一の ident）
          if ident then
            # composite の旧文法の構文処理へ渡す．セル外の attr_ext = Cell.attr; 構文の処理に渡す
            #                        export_name, internal_cell_name, internal_cell_elem_name
            decl = CompositeCelltype.new_join( ident, @name, join.get_name, :ATTRIBUTE )  # mikan a::b.ePort がエラーにならないかも
            if ! decl.instance_of? Decl then
              return
            end
            ini = decl.get_initializer
            if ini == nil then
              return
            end
            # 以下の旧文法実装に渡す．
            # 旧文法では cell に初期値を与えることで、composite で属性の初期値を指定することができた
            # attribute で指定された初期値を cell の属性として処理させる
            join.change_rhs( ini )
          else
            # ident がない．定数式
          end
        else
          # celltype の属性として、この join の名前がない
          # 以下の join.set_definition の中でエラーとなる
        end
      else
        return    # celltype がない．すでにエラー
      end
    elsif join.get_rhs.instance_of? Array then
      rhs = join.get_rhs
      if rhs[0] == :COMPOSITE then
        # composite の中でないのに attr = composite.attr が使われた
        cdl_error( "S1035 composite : cannot specify out of composite celltype definition"  )
        return
      end
    end

    # 以下 composite 文法変更前からある処理

    # 既に左辺が同じ名前の初期化が存在するか？
    j = @join_list.get_item( join.get_name )   # mikan NamespacePath がパスを持っている
    if j.instance_of? Join then    # mikan ここでは j が Join or Nil 以外は、ないはず

      # debug
      dbgPrint "add_array_member: #{@name} port: #{j.get_port_name} rhs: #{j.get_rhs}, #{join.get_port_name} #{join.get_rhs}\n"
      # 呼び口配列（であると仮定して）要素を追加
      j.add_array_member join

    else
      dbgPrint "new_join: cell=#{@name} add_item=#{join.get_name}\n"
      # join
      @join_list.add_item( join )
    end

    # if get_owner then   # error S1030 発生時 get_owner が見つからなくて例外になる
    #   dbgPrint "Cell#new_join: #{get_owner.get_name}.#{@name}\n"
    # else
    #   dbgPrint "Cell#new_join: \"owner not fund\".#{@name}\n"
    # end
    if ! @in_composite then
     if join.get_cell
       dbgPrint "new_join: #{@name} #{@region.get_name} => #{join.get_cell.get_name} #{join.get_cell.get_region.get_path_string}\n"
     end
#     p "region: generate? #{@region.is_generate?}"
    end

  end

  #=== Cell.新しい逆結合
  def self.new_reverse_join( reverse_join )
    @@current_object.new_reverse_join( reverse_join )
  end

  #=== Cell#新しい逆結合
  def new_reverse_join( reverse_join )
    dbgPrint( "new_reverse_join name=#{reverse_join.get_name}\n")
    b_cb = false
    if @celltype then
      ep_name = reverse_join.get_name
      port = @celltype.find ep_name
      if port && port.get_signature
        if port.get_signature.is_callback? then
          b_cb = true
        end
      end
    end
    if ! @b_prototype && ! b_cb then
      cdl_error( "S9999 '$1': reverse join can be used in prototype cell, or with callback signature", @name )
    end
    if @reverse_join_list == nil then
#      @reverse_join_list = NamedList.new( reverse_join, "in cell '#{@name}'" )
      @reverse_join_list = [ reverse_join ]
    else
#      @reverse_join_list.add_item( reverse_join )
      @reverse_join_list << reverse_join
    end
  end

  #=== Cell#逆結合から結合を生成
  # STAGE: S
  def create_reverse_join
    if @b_checked then
      return
    end

    if @reverse_join_list then
#      @reverse_join_list.get_items.each{ |rj|
      @reverse_join_list.each{ |rj|
        # 逆結合の情報を得る
        ep_name = rj.get_name
        ep_subscript, cp_cell_nsp, cp_name, cp_subscript = rj.get_rhs_cell_and_port

        # 呼び口側のセルと、そのセルタイプ
        if ! @in_composite then
          cell = Namespace.find cp_cell_nsp
        else
          cell = CompositeCelltype.find cp_cell_nsp.to_s.to_sym
        end

        if ! cell.instance_of? Cell then
          cdl_error( "S9999 '$1': not cell for reverse join", cp_cell_nsp.get_path_str )
          next
        end
        ct = cell.get_celltype
        if ct == nil then
          next
        end

        if ! @in_composite then
          ep_cell_nsp = get_namespace_path
          ep_cell_nsp_str = ep_cell_nsp.get_path_str
        else
          ep_cell_nsp = NamespacePath.new @name, false
          ep_cell_nsp_str = @name
        end
        ep_subscript_val = ep_subscript ? ep_subscript.eval_const( nil ) : nil
        rhs = Expression.create_cell_join_expression( ep_cell_nsp, ep_subscript_val, ep_name, rj.get_locale )
        join = Join.new( cp_name, cp_subscript, rhs, rj.get_locale )
        cell.new_join( join )
        # join.set_definition( ct.find(join.get_name) )
        if cp_subscript then
          ss_str = "[#{cp_subscript}]"
        else
          ss_str = ""
        end
        dbgPrint "create_reverse_join: #{cell.get_name}.#{cp_name}#{ss_str} => #{ep_cell_nsp_str}.#{ep_name}\n"
      }
    end
  end

  def self.external_join( internal_cell_elem_name, export_name, b_composite )
    @@current_object.external_join( internal_cell_elem_name, export_name, b_composite )
  end

  #=== Cell# cell 内に記述する呼び口の外部結合
  # internal_cell_elem_name:: string : 呼び口名
  # export_name:: string: composite の外部に公開する呼び口名
  #  呼び口を外部結合する．
  #  このメソッドは、composite の中の cell でしか呼ばれない．
  def external_join( internal_cell_elem_name, export_name, b_composite )

    # cCall => composite.cCall; ではないか？
    if( b_composite == false )then
      # cCall => cCall; のような場合
      if @celltype.find( export_name ) then
        cdl_error( "S1036 $1 : cannot refer to $2\'s here. Use \'composite.$3\' to refer to composite celltype\'s" , export_name, @celltype.get_name, export_name )
      end
    end
    # composite の旧文法における、cell 外の cCall = Cell.cCall; の構文処理に渡す
    CompositeCelltype.new_join( export_name, @name,  internal_cell_elem_name, :CALL )
  end

  def self.end_of_parse f_def
    cell = @@current_object
    cell.end_of_parse f_def
    @@current_object = nil
    return cell
  end

  def end_of_parse f_def
    if @b_prototype then  # prototype 指定子あったか?
      f_def = false       # プロトタイプ宣言とする
      @b_prototype = false
    end
    if f_def == false then
      # cell tCelltype Cell; の形式の場合
      # f_def == true の場合 new_def で、呼出される
      set_specifier_list( Generator.get_statement_specifier )
    end
    if TECSGEN.post_coded?
      @b_post_code_generated = true
    end
    set_f_def f_def

    if @generate then
      cell_plugin
    end
  end

  #=== Cell# プロトタイプ宣言(false)か定義(true)かを設定
  #    このメソッドは構文解釈の最後に呼出される
  #f_def::     bool     false if prototype, true if definition
  def set_f_def f_def
    if ! f_def then
      return
    end

    if ! @in_composite then
      # if @celltype.instance_of? Celltype then
      if @celltype then  # composite でも呼びだす, エラー時 nil
        @celltype.new_cell self
      end
      @@cell_list << self
    end
  end

  def set_f_ref
    dbgPrint "set_f_ref: #{@global_name}\n"
    @f_ref = true

    # composite の内部セルを参照されたことにする
    # 今のところ問題ないが、未参照であるべきものまで参照されたことになる
    if @cell_list then
      @cell_list.each{ |cn,cell|
        cell.set_f_ref
      }
    end
  end

  #=== Cell# cell の指定子を設定
  # STAGE:  B
  #
  #    bnf.y.rb の statement_specifiler_list
  #spec_list::      [ :ALLOCATOR, [ [ :NORMAL_ALLOC, ep_name, subscript, func_name, param_name, expr ], ... ] ]
  #                     s[0]      s[1]   a[0]        a[1]       a[2]        a[3]     a[4]       a[5]
  #    セルに指定されたアロケータ指定子
  #    a[1] の subscript はこのメソッドの中で Expression から Integer に評価される
  #    受け口側に生成されるアロケータ呼び口の結合を内部生成する
  #    呼び口側は Port の create_allocator_join にて生成
  #    リレーアロケータの場合 create_relay_allocator_join にて生成す
  def set_specifier_list( spec_list )
    return if spec_list == nil  # 空ならば何もしない

    dbgPrint( "set_spec_list: #{@name}\n" )
    b_generate = false   # generate が指定された

    spec_list.each{ |s|
      case s[0]             # statement_specifier
      when :ALLOCATOR       # [allocator(ePort.func.param=allocCell.eA,ePort.func2.param=allocCell.eA)]
        s[1].each { |a|     # alloc_list : allocator の内部の ',' で区切られた部分の配列
          cp_name = :"#{a[0+1]}_#{a[2+1]}_#{a[3+1]}"    # アロケータ呼び口の名前：'=' の左辺を '.' に変えて '_' で連結
          # p "#{a[0]} #{a[0+1]} #{a[2+1]} #{a[3+1]} #{cp_name}"
          if a[1+1] then
            subscript = a[1+1].eval_const nil
            a[1+1] = subscript
          else
            subscript = nil
          end
          # アロケータ呼び口の結合を生成
          join = Join.new( cp_name, subscript, a[4+1] )   # 構文解析段階なので locale 不要
          dbgPrint( "new allocator join #{cp_name} #{subscript} #{a[4+1]}\n" )
          Cell.new_join( join )
          @alloc_list << a 
        }
      when :ID          # [id(0)]
        if ! s[1].instance_of? Expression then
          cdl_error( "S1160 $1 must be constant for id", s[1].to_s )
        else
          id = s[1].eval_const nil
          if id == nil || Integer(id) != id then
            cdl_error( "S1161 $1 must be constant for id", s[1].to_s )
          elsif id == 0 then
            cdl_error( "S1162 $1: id cannot be 0", s[1].to_s )
          else
            @id_specified = id
          end
        end
      when :GENERATE      # [generate(CellPlugin,"option")]
        if @generate then
          cdl_error( "S1163 generate specifier duplicate"  )
        end
        @generate = [ s[1], s[2] ] # [ PluginName, "option" ]
        b_generate = true
      when :PROTOTYPE     # [prototype]
        @b_prototype = true
      when :RESTRICT      # [restrict]
        s[1].each{ |re|
          add_restrict re[0], re[1], re[2]
        }
      when :THROUGH       # [through(ThroughPlugin,"option")]
        ep_name    = s[1].to_sym
        pluginName = s[2]
        option     = CDLString.remove_dquote s[3].to_s
        dbgPrint( "through: celltype=#{@celltype.get_name} ep_name=#{ep_name}\n" )
        if @celltype.find( ep_name ) == nil then
          cdl_error( "S9999 '$1' entry port not exist", ep_name )
        end
        @ep_through_list << [ ep_name, pluginName, option ]      # [ ep_name, pluginName, "option" ]
      else
          cdl_error( "S1039 \'$1\': unknown specifier for cell" , s[0] )
      end
    }
    if @b_prototype then
      if b_generate then
         cdl_error( "S9999 '$1': generate and prototype specified simultaneously" , @name )
      end
      if @b_defined then
         cdl_error( "S9999 '$1': prototype specified after definition" , @name )
      end
    end
  end

  def get_allocator_list

    # 意味チェック(set_definition)されていない？
    # relay アロケータの場合、セルの意味チェックが行われていないと、@alloc_list が完成しない
    if @b_checked == false then
      set_definition_join
    end
    @alloc_list
  end

  def get_specified_id
    @id_specified
  end

  #=== id 指定子の値を設定
  # このメソッドは、プラグインで cell の生成順序を制御したい場合のために設けた
  # 通常の id 指定子では使っていない
  def set_specified_id id
    if Integer( id ) != id || id <= 0 then
      cdl_error( "S1164 '$1' set_specified_id: id not positive integer '$2'", @name, id )
    elsif @id_specified then
      cdl_error( "S1165 '$1' set_specified_id: id duplicate", @name )
    else
      @id_specified = id
    end
  end

  #=== Cell# セルプラグイン (generate 指定子)
  def cell_plugin
    plugin_name = @generate[0]
    option = @generate[1]
    @generate[2] = apply_plugin plugin_name, option
  end

  def apply_plugin plugin_name, option
    if ! @b_defined then
      cdl_error( "S9999 plugin cannot apply to prototype cell '$1'", @name )
    end

    plClass = load_plugin( plugin_name, CellPlugin )
    # return if plClass == nil # 従来と仕様が変わるので、継続する
    if $verbose then
      print "new cell plugin: plugin_object = #{plClass.class.name}.new( #{@name}, #{option} )\n"
    end

    begin
      plugin_object = plClass.new( self, option )
      plugin_object.set_locale @locale
      generate_and_parse plugin_object
    rescue Exception => evar
      cdl_error( "S1166 $1: fail to new", plugin_name )
      print_exception( evar )
    end
    return  plugin_object
  end

  def add_compositecelltypejoin join
    @compositecelltypejoin_list.add_item join
  end

  # mikan 以下のコードが数か所ある。
  # compositecelltypejoin_list が大昔の仕様によいようになっている
  def get_compositecelltypejoin_by_cell_elem_name cell_elem_name
    @compositecelltypejoin_list.get_items.each { |cj|
      if cj.get_cell_elem_name == cell_elem_name then
        return cj
      end
    }
    return nil
  end

  #=== Cell# cell を composite セルタイプのセル用に clone する
  #name::        string : 親 cell の名前  (cell tComposite cell1 での cell1)
  #global_name:: string : 親 cell の global_name 
  #join_array::  Join[] : composite の cell の join で、この cell に対応するもの
  #ct_name::     string : 親セルのセルタイプ名
  #region::      Region : 元のセルが属する region
  #このメソッドは CompositeCelltype の expand から呼出される
  def clone_for_composite( name, global_name, namespacePath, join_array, ct_name, region, plugin, locale )

    # debug
    dbgPrint "  CLONING Cell#clone_for_composite : cloning: #{@name} #{global_name}  b_defined=#{@b_defined} #{self}=>#{@my_clone} \n"
    dbgPrint "              my_name=#{@name} name=#{name} owner class=#{@owner.class.name}\n"

    @my_clone = self.clone

    # clone したセルの内部に持つ名前情報を調整する
    @my_clone.set_cloned( name, global_name, namespacePath, join_array, ct_name, region, plugin, locale )

    # @celltype == nil は以前にセルタイプ未定義エラー
    if @b_defined == true && @celltype != nil then
      if @celltype.instance_of?( Celltype ) then
        # celltype に登録（コード生成の対象となる）
        @celltype.new_cell( @my_clone )
      end
    end

    return @my_clone
  end

  #=== Cell# clone されたセルの内部に持つ名前情報を調整する
  #name::        string : 親 cell の名前  (cell tComposite cell1 での cell1)
  #global_name:: string : 親 cell の global_name
  #join_array::  Join[] : composite の cell の join で、この cell に対応するもの
  #parent_ct_name:: string : 親セルのセルタイプ名（composite セルタイプ）
  #  このメソッドはすぐ上の clone_for_composite から呼出され、clone されたセルを整える
  def set_cloned( name, global_name, namespacePath, join_array, parent_ct_name, region, plugin, locale )

    # debug
    dbgPrint "cell.set_cloned : global_name: #{global_name}  name: #{name}  @name: #{@name}\n"
    dbgPrint "set_cloned:  entry_array_max_subscript.len=#{@entry_array_max_subscript.length}\n"
    @global_name = :"#{global_name}_#{@name}"
    @name = :"#{name}_#{@name}"
    @NamespacePath = namespacePath.change_name @name
    @region = region
    @plugin = plugin
    @locale = locale

    @in_composite = false
    @b_checked = false
    @f_cloned = true

    # Namespace.new_cell( self )  # mikan namespace 対応
    region.new_cell( self )  # mikan  namespace に cell を置けないことを仮定

    # join_list : NamedList の clone を作る
    if @celltype then
      dbgPrint "set_cloned: celltype=#{@celltype.get_name} name=#{@name} global_name=#{global_name} region=#{region.get_name}\n"
    end
    @join_list = @join_list.clone_for_composite( parent_ct_name, global_name, locale )
    @referenced_port_list = {}

    @alloc_list = []
    @require_joined_list = {}
    @entry_array_max_subscript = @entry_array_max_subscript.dup
    @cell_list = {}
    @cell_list2 = []

    # このセルのグローバル名を与える
    # C_EXP の$id$ 置換はこのセルの名前になる
    join_array.each { |j|
      @join_list.change_item j
    }
  end

  #=== clone されたセルが composite の場合、内部セルを展開する
  #self:: clone されたセルでなければならない
  def expand_inner
    if ! @f_cloned then
      raise "expnad_inner: not cloned cell"
    end

    # clone しようとするセルが composit セルタイプ？
    if @celltype.instance_of?( CompositeCelltype ) then
      # composite cell を再帰的に展開
      @cell_list, @cell_list2 = @celltype.expand( @name, @global_name, @NamespacePath, @join_list, @region, @plugin, @locale )
    end
  end

  #=== Cell# clone された cell の join_list の右辺の変更
  #  呼び口の右辺の cell を他の clone された cell に置換え
  def change_rhs_port cloned_cell_list

    # debug
    dbgPrint "=====   Cell#change_rhs_port: name=#{@name}   =====\n"

    @join_list.get_items.each { |j|
      j.change_rhs_port( cloned_cell_list, @celltype )
    }
  end

  def get_f_def
    @b_defined
  end

  def get_f_ref
    if @f_ref then
      return true
    else
      return false
    end
  end

  def get_name
    @name
  end

  def get_local_name
    @local_name
  end

  def get_global_name
    @global_name
  end

  def get_region
    @region
  end

  def get_domain_class_root
    dr = @region.get_domain_root
    cr = @region.get_class_root
    if dr.is_sub_region_of? cr then
      return dr
    else
      return cr
    end
  end
  
  def get_ep_through_list
    dbgPrint( "Cell#get_ep_through_list: name=#{@name} len=#{@ep_through_list.length}\n")
    @ep_through_list
  end

  def self.get_current
    @@current_object
  end

  #=== Cell# 生成されるセルか？
  # 最適化、コード生成中に、対象となる region に属する場合 true を返す
  def is_generate?
    if $generating_region == nil then
      # 構文解釈、意味解析段階で呼ばれると例外発生
      raise "is_generate? called before optimizing"
    end

    # print "Cell#is_generate?: #{@name} #{@region.get_name} #{$generating_region.get_name}\n"
    if $generating_region == @region.get_link_root then
      return true
    else
      return false
    end
  end

  #=== Cell# composite 内部の複製されたセルか？
  # composite 定義の内部のセル (@in_composite = true) ではない
  def is_cloned?
    @f_cloned
  end

  #=== Cell# composite 内部のセルか？
  def is_in_composite?
    @in_composite
  end

  #=== Cell# composite のセルか？
  def is_of_composite?
    if @celltype.kind_of? CompositeCelltype
      return true
    else
      return false
    end
  end

  #=== Cell# tmp_plugin_post_code.cdl で生成されたセルか？
  def post_code_generated?
    @b_post_code_generated
  end

  # composite cell の port に対応する内部の cell の port の名前（リンク時に必要な名前）
  def get_real_global_name port_name
    if @celltype.instance_of?( CompositeCelltype ) then

      # debug
      dbgPrint "get_real_global_name: cell name: #{@name} #{@local_name} #{@global_name} #{port_name}\n"
      @cell_list.each{ |n,c|
        dbgPrint "   name: #{n}\n"
        dbgPrint " get_name: #{c.get_name} local_name: #{c.get_local_name}\n"  if c
        dbgPrint "\n\n"
      }

      cj = @celltype.find_export( port_name )

      # debug
      dbgPrint " composite join name: #{cj.get_name}  cell: #{cj.get_cell_name}  cell elem: #{cj.get_cell_elem_name}\n"

      name = @cell_list[ "#{cj.get_cell_name}" ].get_real_global_name( cj.get_cell_elem_name )
      return name

    else
      # debug
      dbgPrint "  get_real_global_name: cell name: #{@global_name}\n"

      return @global_name
    end
  end

  #=== Cell# セルの受け口 port_name に対する実際のセル名、受け口名を '_' で連結
  #    namespace 名 + '_' + セル名 + '_' + 受け口名   （このセルが composite ならば展開後のセル名、受け口名）
  def get_real_global_port_name port_name

    # composite か？
    if @celltype.instance_of?( CompositeCelltype ) then

      # debug
      dbgPrint "get_real_global_port_name: cell name: #{@name} #{@local_name} #{@global_name} #{port_name}\n"
      @cell_list.each{ |n,c|
        dbgPrint "   name: #{n}\n"
        dbgPrint " get_name: #{c.get_name} local_name: #{c.get_local_name}\n"  if c
        dbgPrint "\n"
      }

      # セルタイプ内で port_name の CompositeCelltypeJoin を探す（コード生成段階では必ず見つかる）
      cj = @celltype.find_export( port_name )

      # debug
      dbgPrint "   composite join name: #{cj.get_name}  cell: #{cj.get_cell_name}  cell elem: #{cj.get_cell_elem_name}\n"

      # composite の内部のセルに対し再帰的に get_real_global_port_name を適用
      name = @cell_list[ "#{cj.get_cell_name}" ].get_real_global_port_name( cj.get_cell_elem_name )
      return name

    else
      # debug
      dbgPrint "get_real_global_port_name:  cell name: #{@global_name}\n"

      return "#{@global_name}_#{port_name}"
    end
  end

  #=== Cell# PORT (celltype の定義) を得る
  def get_real_port( port_name )

    # composite か？
    if @celltype.instance_of?( CompositeCelltype ) then

      # セルタイプ内で port_name の CompositeCelltypeJoin を探す（コード生成段階では必ず見つかる）
      cj = @celltype.find_export( port_name )

      # composite の内部のセルに対し再帰的に get_real_port を適用
      port = @cell_list[ "#{cj.get_cell_name}" ].get_real_port( cj.get_cell_elem_name )
      return port
    else

      return @celltype.find( port_name )
    end
  end

  #=== Cell# cell を得る
  #    composite でなければ自分自身を返す
  def get_real_cell( port_name )

    # composite か？
    if @celltype.instance_of?( CompositeCelltype ) then

      # セルタイプ内で port_name の CompositeCelltypeJoin を探す（コード生成段階では必ず見つかる）
      # print "get_real_cell: cell=#{@name} port=#{port_name}\n"
      # pp @cell_list
      cj = @celltype.find_export( port_name )

      # composite の内部のセルに対し再帰的に get_real_port を適用
      cell = @cell_list[ "#{cj.get_cell_name}" ].get_real_cell( cj.get_cell_elem_name )
      return cell
    else

      return self
    end
  end

  #=== Cell#get_real_celltype
  #
  def get_real_celltype( port_name )
    if @celltype.instance_of?( CompositeCelltype ) then
      return @celltype.get_real_celltype port_name
    else
      return @celltype
    end
  end

  #=== Cell# 受け口のport の参照カウントをアップする
  #port_name:: Symbol  : ポート名
  def port_referenced port
    if @referenced_port_list[ port ] then
      @referenced_port_list[ port ] += 1
    else
      @referenced_port_list[ port ] = 1
    end

    # composite か？
    if @celltype.instance_of?( CompositeCelltype ) then

      # セルタイプ内で port_name の CompositeCelltypeJoin を探す（コード生成段階では必ず見つかる）
      cj = @celltype.find_export( port.get_name )

      dbgPrint " port_referenced: #{@celltype.get_name} #{@name} cj=#{cj&&(cj.get_name)||"nil"}\n"

      if cj then  # 既にエラー
        # composite の内部のセルに対し再帰的に get_real_port を適用
        cell = @cell_list[ "#{cj.get_cell_name}" ]
        if cell && cell.get_celltype then
          cell.port_referenced( cell.get_celltype.find( cj.get_cell_elem_name ) )
        end
      end
    end
  end

  def get_internal_port_name port_name
    if @celltype.instance_of?( CompositeCelltype ) then
      cj = @celltype.find_export( port_name )
#      return "#{@name}_#{cj.get_cell.get_internal_port_name cj.get_cell_elem_name}"
      return cj.get_cell.get_internal_port_name( cj.get_cell_elem_name )
    else

      # debug
      dbgPrint "  get_global_port_name: cell port: #{@global_name}_#{port_name}\n"

      return "#{@global_name}_#{port_name}"
    end
  end

  #Cell#属性の初期値を得る
  #attr_name::Symbol  必ず初期化されていないと Ruby 例外となる
  def get_attr_initializer attr_name
    val = @join_list.get_item( attr_name )
    if val == nil then
      val = (@celltype.find  attr_name).get_initializer
    else
      val = val.get_rhs
    end
    return val
  end

  def get_celltype
    @celltype
  end

  def get_join_list
    @join_list
  end

  def set_id id
    @id = id
  end

  def get_id
    @id
  end

  def get_plugin
    @plugin
  end

  def get_cell_list2
    list = []
    @cell_list2.each{ |cell|
      list << cell
      list += cell.get_cell_list2
    }
    return list
  end

  #=== Cell# 受け口配列の添数の最大値を設定
  def set_entry_port_max_subscript( port, num )
    dbgPrint( "set_entry_port_max_subscript: #{@name}.#{port.get_name}: #{num}\n" )
    subscript = @entry_array_max_subscript[port]

    if subscript == nil || num > subscript then
      @entry_array_max_subscript[port] = num
      set_entry_inner_port_max_subscript( port, num )
    end
  end

  #=== Cell# composite の内側セルの受け口配列の添数の最大値を設定
  def set_entry_inner_port_max_subscript( port, num )
    if @cell_list == nil then
      return    # プロトタイプ宣言しかされていなくて、内側セルが展開されていない　or composite 展開前
    end

    # composite の内側のセルに伝播
    if @celltype.instance_of? CompositeCelltype then
      dbgPrint "set_entry_inner_port_max_subscript #{@name} #{@port} #{num} cell_list.len=#{@cell_list.length}\n"
      # @cell_list.each{ |c, p| print c, p, '\n' }

      cj = @celltype.find_export port.get_name
      if cj && @cell_list[ cj.get_cell_name.to_s ] then
        inner_cell = @cell_list[ cj.get_cell_name.to_s ]
        ct = inner_cell.get_celltype
        if ct then
          inner_port = ct.find( cj.get_cell_elem_name )
          inner_cell.set_entry_port_max_subscript( inner_port, num )
        end
      end
    end
  end

  #=== Cell# 受け口配列の添数の最大値を返す
  # 長さは +1 する
  # 1つもない場合は -1 を返す
  def get_entry_port_max_subscript( port )
    subscript = @entry_array_max_subscript[port]
    if subscript == nil then
      subscript = -1
    end
    return subscript
  end

  #=== Cell# リレーアロケータの結合を生成
  # STAGE: S
  # 呼び口側の結合を元に受け口側の結合を生成
  def create_relay_allocator_join

    # celltype がなければチェックしない（既にエラー）
    return if @celltype == nil

    # relay allocator を生成
    @celltype.get_port_list.each { |p|
      ail = p.get_allocator_instance
      if ail then
        dbgPrint "create_relay_allocator_join: #{@name}, #{p.get_name}\n"
        if p.get_array_size then
          # mikan relay allocator が array に対応できてもよいのでは？
          cdl_error( "S1040 array not supported for relay allocator"  )
          next
        end
        ail.each{ |name,ai2|
          # ai2 = [ :INTERNAL_ALLOC|:RELAY_ALLOC, func_name, param_name, rhs_cp_name, rhs_func_name, rhs_param_name ]
          if ai2[0] == :RELAY_ALLOC then
            dbgPrint "create_relay_allocator_join: #{@name}, #{name}\n"
            # 呼び口側の結合を取り出す
            ja = @join_list.get_item( :"#{ai2[3]}_#{ai2[4]}_#{ai2[5]}" )
            if ja == nil then
              # 見つからない場合
              found = false
              
              # composite 内で外部に結合されているか
              if @in_composite then
                @compositecelltypejoin_list.get_items.each { |cj|
                  dbgPrint( "create relay_allocator in_composite\n" )
                  dbgPrint("    #{cj.get_cell_name} #{@name} #{cj.get_cell_elem_name} #{ai2[3]}_#{ai2[4]}_#{ai2[5]}\n")
                  if cj.get_cell_name == @name &&
                      cj.get_cell_elem_name == :"#{ai2[3]}_#{ai2[4]}_#{ai2[5]}" then
                    found = true
                    dbgPrint "create_relay_allocator: found #{cj.get_cell_elem_name}\n"
                    break
                  end
                }
              end

              if found == false then
                cdl_error( "S1041 \'$1_$2_$3\': not joined. cannot create internal join for relay allocator" , ai2[3], ai2[4], ai2[5] )
                # print( "      In cell #{get_name}\n" )
                # join が未結合であることのエラーは二度でる (S1043)
              end
              next    # 打ち切る
            end

            b_export = false
            # composite 内のセルでエクスポートされているかチェック
            #  mikan エクスポート側と、こちら側で、リレー先が一致するかチェックが必要
            if @compositecelltypejoin_list then
              # export されているか調べる
              @compositecelltypejoin_list.get_items.each{ |cj|
                # 属性名と composite の export する名前は一致するか
                if p.get_name == cj.get_cell_elem_name then
                  # print "export : #{p.get_name}\n"
                  b_export = true    # 属性は export されているので、とりあえず未初期化とはしない
                  break
                end
              }
              # 
            end

            # mikan 配列
            am = nil
            if am then
              am.each{ |ja2|
                rhs = ja2.get_rhs
                subscript = ja2.get_subscript
                if b_export == false then
                  # CompositeCelltype の場合、内側のセルで生成させる
                  join = Join.new( :"#{p.get_name}_#{ai2[1]}_#{ai2[2]}", subscript, rhs, @loacle )
                  # p ( "#{p.get_name}_#{ai2[1]}_#{ai2[2]}", subscript, rhs )
                  new_join( join )
                  join.set_definition( @celltype.find(join.get_name) )
                  # mikan relay mismatch チェックができていない（下方を参照）
                end
                @alloc_list << [ :NORMAL_ALLOC, p.get_name, subscript, ai2[1], ai2[2], rhs ]
              }
            else
              if b_export == false then
                # CompositeCelltype の場合、内側のセルで生成させる
                join = Join.new( :"#{p.get_name}_#{ai2[1]}_#{ai2[2]}", nil, ja.get_rhs, @locale )
                new_join( join )
                join.set_definition( @celltype.find(join.get_name) )
                if @celltype.instance_of? CompositeCelltype then
                  jr = @join_list.get_item( :"#{ai2[3]}_#{ai2[4]}_#{ai2[5]}" )
                  if jr.get_rhs_cell2 != join.get_rhs_cell2 || jr.get_rhs_port2 != join.get_rhs_port2 then
                    cdl_error( "S1167 \'$1\': relay mismatch \'$2\'",
                                      "#{p.get_name}_#{ai2[1]}_#{ai2[2]}",
                                      "#{ai2[3]}_#{ai2[4]}_#{ai2[5]}" )
                    # 本当は composite の呼び口と受け口の間で行うべきだが、内部で多段接続されている場合
                  else
                    dbgPrint "relay success:  #{p.get_name}_#{ai2[1]}_#{ai2[2]}=>#{ai2[3]}_#{ai2[4]}_#{ai2[5]} #{jr.get_rhs_cell2.get_name}.#{jr.get_rhs_port2} \n"
                  end
                end
              end
              @alloc_list << [ :NORMAL_ALLOC, p.get_name, nil, ai2[1], ai2[2], ja.get_rhs ]
            end
            dbgPrint "create_relay_allocator_join: #{p.get_name}_#{ai2[1]}_#{ai2[2]} #{ai2[3]}_#{ai2[4]}_#{ai2[5]}\n"
          end
        }
      end
    }
  end

  #=== Cell# @@cell_list2 を作る
  # @@cell_list2 は、出現順に composite 内を含むセルのリスト
  def self.make_cell_list2
    @@cell_list.each{ |c|
      @@cell_list2 << c
      @@cell_list2 += c.get_cell_list2
    }
  end

  #=== Cell# @@cell_list2 を得る
  # composite 内を含む (compositeも含む)
  # 意味解析後に作成される
  def self.get_cell_list2
    @@cell_list2
  end

  #=== Cell# @@cell_list を得る
  #composite の中を含まない
  def self.get_cell_list
    @@cell_list
  end

  #=== Cell# reverse_join を生成する
  def self.create_reverse_join
    @@cell_list.each{ |c|
      ct = c.get_celltype
      # if c.is_generate? then
      if ct then
        c.create_reverse_join
      end
      # end
    }
  end

  #=== Cell# reverse_require_join を生成する
  def self.create_reverse_require_join
    @@cell_list2.each{ |c|
      ct = c.get_celltype
      # if c.is_generate? then
        if ct then
          # self への呼び口側の結合を生成
          ct.create_reverse_require_join c
        end
      # end
    }
  end

  #=== Cell# 受け口のport の参照カウントを設定する
  # self は呼び元のセル
  # 呼び先セルの受け口の参照カウントをアップする
  def set_port_reference_count
    @join_list.get_items.each { |j|
      if j.get_definition.instance_of? Port then
        am = j.get_array_member2
        if am then             # 呼び口配列
          am.each { |j2|
            next if j2 == nil    # optional で一部が欠落しているケース
            cell = j2.get_rhs_cell2
            next if cell == nil     # 右辺が見つからなかった．既にエラー
            port = cell.get_celltype.find( j2.get_rhs_port2 )
            dbgPrint( "set_port_reference_count: #{@name}.#{j2.get_name} => #{cell.get_name}.#{port.get_name}\n")
            cell.port_referenced port
          }
        else
          cell = j.get_rhs_cell2
          next if cell == nil || cell.get_celltype == nil     # 右辺が見つからなかった．既にエラー
          port = cell.get_celltype.find( j.get_rhs_port2 )
          if port == nil then
            dbgPrint "set_port_ref: #{@name}.#{j.get_name} = #{cell.get_name}.#{j.get_rhs_port2}\n"
            # through プラグインで生成されたセルの受け口が見つからないケース (のハズ)
            cdl_error( "entry '$1' not found in '$2' refered from $3.$4", j.get_rhs_port2, cell.get_name, @name, j.get_name )
            next
          end
          dbgPrint( "set_port_reference_count: #{@name}.#{j.get_name} => #{cell.get_name}.#{port.get_name}\n")
          cell.port_referenced port
        end
      end
    }
  end

  #=== Cell# 結合(Join)のチェック
  #     Join は呼び口の結合または attribute の初期化
  #
  #  mikan このメソッドは、以下の４つのチェックからなるが、分割したほうがより適切な長さのメソッドになる
  #  ・リレーアロケータの生成 => create_relay_allocator_join
  #  ・未結合の呼び口のチェック
  #  ・ポインタ型が配列で初期化される場合のチェック
  #  ・未初期化の属性のチェック
  def check_join

    # celltype がなければチェックしない（既にエラー）
    return if @celltype == nil
    return if @b_defined == false
    return if @f_cloned == true    # 内部セルについては、composite の定義時にチェックされている

    # debug
    # if @compositecelltypejoin_list then
    #   p "check_join"
    #   @compositecelltypejoin_list.get_items.each { |cj| p "#{cj.get_name} #{cj.get_name.object_id}" }
    # end

    # 未結合の呼び口のチェック
    @celltype.get_port_list.each { |p|

      # 呼び口でなければ、チェックしない
      next if p.get_port_type != :CALL

      # debug
      dbgPrint "check_join: #{@name} #{get_celltype.get_name} #{p.get_name}\n"

      # 結合リストの中から呼び口名に一致するものを取りだす
      j = @join_list.get_item( p.get_name )

      if j == nil then
        # 未結合の呼び口

        # composite celltype の内部の場合、composite celltype が export する呼び口に結合されているか探す
        found = false
        if @in_composite then
          # composite celltype の export するものすべてから探す
          # （export するものの右辺値から探すために get_item ではダメ）
          @compositecelltypejoin_list.get_items.each{ |cj|
            # 呼び口名と composite の export する名前は一致するか
            if p.get_name == cj.get_cell_elem_name then
              found = true
            end
          }
        end

        # 呼び口配列の場合 optional で全ての要素が初期化されない場合に、ここへ来る
        if ! found && ! p.is_require? && ! p.is_optional? then
          if ! p.is_allocator_port? then
            cdl_error( "S1042 call port \'$1\' not initialized in cell \'$2\'" , p.get_name, @name )
          else
            cdl_error( "S1043 call port \'$1\' not initialized in cell \'$2\'. this call port is created by tecsgen. check allocator specifier" , p.get_name, @name )
          end
        end
      elsif p.get_array_size.kind_of? Integer then
        # 添数あり呼び口配列の場合、すべての添数要素が初期化されているかチェックする

        am = j.get_array_member2
        if( am )then
          # join は配列

          # 呼び口配列定義での配列の大きさ
          length = p.get_array_size

          # 配列の大きさが呼び口配列定義と結合定義で一致するか？
          if am.length != length then
            if ! p.is_optional? || am.length >= length then
              # optional の場合、要素数が少なすぎるのは OK
              cdl_error( "S1044 $1: array initializer too many or few, $2 for $3" , p.get_name, am.length, length )
            end

            # am の要素に nil を追加しておく (#_CPA_# のコード生成時、この配列要素数分生成)
            i = am.length
            while i < length
              am << nil
              i += 1
            end
          end

#          # 配列要素の抜けがないかチェック
#          if am.length < length then  # 満たない場合既にエラーだが要素のある範囲でチェック
#            length = am.length
#          end
          i = 0
          while( i < length )
            if am[i] == nil then
              if ! p.is_optional? then
                cdl_error( "S1045 $1[$2]: not initialized" , p.get_name, i )
              end
            else
              # 生成されないリージョンへの結合かチェック
              if ! @in_composite then
                am[i].check_region2
              end
            end
            i += 1
          end

        # else
        # join が非配列であれば、既にエラー
        end
      elsif j.get_array_member then
        # 添数なし呼び口配列の場合
        am = j.get_array_member2
        length = am.length
        i = 0
        while i < length
          if am[i] == nil then
            if ! p.is_optional? then
              cdl_error( "S1046 $1[$2]: not initialized" , p.get_name, i )
            end
          end
          i += 1
        end

        # 生成されないリージョンへの結合かチェック
        if ! @in_composite then
          am.each { |join|
            if join then
              join.check_region2
            end
          }
        end
      else
        # 呼び口［配列」でない場合

        # 生成されないリージョンへの結合かチェック
        if ! @in_composite then
          j.check_region2
        end

      end # j != nil
    }

    # ポインタ型が配列で初期化される場合のチェック
    (@celltype.get_attribute_list+@celltype.get_var_list).each { |a|
      if a.get_size_is then

        if a.instance_of? CompositeCelltypeJoin then
          # 既にエラーになっている
          # cdl_error( "S1047 size_is pointer cannot be exposed for composite attribute"  )
          next
        end

        if( ! a.get_type.kind_of?( PtrType ) ) then
          cdl_error( "S1048 $1: size_is specified for non-pointer type" , a.get_name )
        else
          size = a.get_size_is.eval_const( @join_list, @celltype.get_name_list )
          a.get_type.set_scs( a.get_size_is, nil, nil, nil, false )
          if( ! size.kind_of? Integer )then               # C_EXP の可能性あり
            # mikan 多分ここでのエラー発生は不要、eval_const の中で変数が存在しない、型が不適切などのエラーになるはず
            cdl_error( "S1049 $1: size_is arg not constant" , a.get_name )
          else
            j = @join_list.get_item( a.get_identifier )
            if j then
              ini = j.get_rhs
              if ini then
                if ! ini.instance_of?( Array ) then
                  cdl_error( "S1050 unsuitable initializer, need array initializer"  )
                elsif size < ini.length then
                  cdl_error( "S1051 too many initializer for array, $1 for $2" , ini.length, size )
                else
                  # a.get_type.set_scs( a.get_size_is, nil, nil )
                end
              end
            else
              # size_is 引数がセルで指定されていて、初期化子がセルタイプで指定されているケースのチェック
              ini = a.get_initializer
              if ini.instance_of? Expression
                ini = ini.eval_const( @celltype.get_name_list )
              end
              if ini.instance_of? Array then
                if( ini.length > size )then
                  cdl_error( "S1168 too many initializer for array, $1 for $2", ini.length, size )
                end
              end
            end
          end
        end
      else
        if ! a.instance_of? CompositeCelltypeJoin then
          # composite は size_is 指定できない
          if a.get_type.kind_of?( PtrType ) then
            j = @join_list.get_item( a.get_identifier )
            if j && j.get_rhs.instance_of?( Array ) then
              ## size_is 指定されていないポインタが Array で初期化されていたら、エラーとする
              cdl_error( "S1169 $1: non-size_is pointer cannot be initialized with array initializer" , a.get_identifier )
            end
          end
        end
      end
    }

    # 未初期化の属性をチェック
    @celltype.get_attribute_list.each { |a|
      b_init = false
      # self.show_tree 1
      if a.get_initializer then                               # セルタイプで初期化されている
        b_init = true
        # @in_composite で export されている場合には、この初期値は使われない
        # export されている、いないに関わらず、初期化されていることが保証される
      elsif @join_list.get_item( a.get_name ) then            # セルで初期化されている
        b_init = true
      elsif @in_composite && @compositecelltypejoin_list then
        # 属性が export されているか調べる。export されていれば未初期化とはしない
        # mikan リニアサーチ
        @compositecelltypejoin_list.get_items.each{ |cj|
          # 属性名と composite の export する名前は一致するか
          if a.get_name.to_sym == cj.get_cell_elem_name.to_sym then
            b_init = true    # 属性は export されているので、とりあえず未初期化とはしない
          end
        }
        if b_init then
          # size_is の引数がマッチするかチェックする
          # 内部セルの size_is をエクスポートする size_is とマッチするかチェックする
          # 内部セルとエクスポートで名前を変えている可能性があるので、内部セルの size_is の名前を変換した上でチェックする
          if a.get_size_is then
            ### p "attr: get_size_is"
            cj = @compositecelltypejoin_list.get_item a.get_name.to_sym
            if cj.get_port_decl.instance_of? Decl then
              ### p "attr: get_size_is 2"
              # cj_size_is は、外部公開される attr の size_is
              cj_size_is = cj.get_port_decl.get_size_is
              if cj_size_is == nil then
                cdl_error( "S1170 \'$1\' has size_is but export attr \'$2\' doesn't have", a.get_name, cj.get_name )
              end
              exprs = a.get_size_is.to_s
              ### p "exprs : ", exprs
              remain = exprs
              inner_to_export = {}
			  ### exprs に含まれる識別子を抜き出し、対応する export される名前を探す
              while remain != "" && remain != nil
                ### p "remain ", remain
                remain =~ /([^\w]*)([_A-Za-z][\w\d]*)/   # 変数名文字列を取り出す 
				if $2 == nil then
						break
				end
                arg_name = $2.to_sym
                remain = $'
                ### p exprs, $1, $2, $'
                # size_is に含まれる変数は、composite で export されているか
                cj2 = nil
                @compositecelltypejoin_list.get_items.each{ |cj2t|
                  if cj2t.get_cell_elem_name == arg_name then
                    cj2 = cj2t
                  end
                }
                if cj2 == nil then
                  cdl_error( "S1171 \'$1\' size_is argument of \'$2\' not exported", a.get_name, cj.get_name )
                  next
                end
                if cj2.get_port_decl.instance_of? Decl then
                   decl2 = cj2.get_port_decl
                   # 内部の名前と外部の名前の対応関係を記憶
                   inner_to_export[arg_name] = decl2.get_name
                # else cj2 は Port (既にエラー)
                end
              end
              # 内部の名前を外部の名前で置換
              inner_to_export.each{ |arg_name, exp_name|
                ### p "changing #{arg_name}=>#{exp_name}"
                # exprs.gsub!( Regexp.new("#{arg_name}[^0-9A-Za-z_]"), exp_name.to_s )
                exprs.gsub!( Regexp.new("#{arg_name}(\\W)"), exp_name.to_s+"\\1" )  # 文字列末尾にないケース
                exprs.gsub!( Regexp.new("#{arg_name}\\Z"), exp_name.to_s )          # 文字列末尾にあるケース
              }
              ### p "changed: #{exprs} #{cj_size_is.to_s}"
              if exprs != cj_size_is.to_s then
                cdl_error( "S1172 \'$1\' size_is argument mismatch with exporting one \'$2\'", a.get_name, cj.get_name )
              end
            # else cj は Port (既にエラー)
            end
          end
        end    
      end

      if b_init == false then
          cdl_error( "S1052 attribute \'$1\' not initialized in cell \'$2\'" , a.get_name, @name )
      end
   
    }
  end

  #=== Cell# 逆 require をチェックする
  # 逆 require 指定された受け口に複数の結合がないかチェックする
  # composite の内部セル (f_cloned=true) もチェックする
  def check_reverse_require
    # celltype がなければチェックしない（既にエラー）
    return if @celltype == nil
    return if @b_defined == false

    # p "check reverse require   #{@name}"
    # 逆require 指定された受け口に複数の結合がないかチェック
    @referenced_port_list.each{ |port,count|
      # p port.class, count
      # p port.get_name, port.get_port_type, port.get_signature.get_name
      if port.is_reverse_required? && count > 1 then
        cdl_warning( "W1009 $1: fixed join entry port has multi join", port.get_name )
      end
    }
  end

  #=== Cell# require 呼び口の結合を行う
  # STAGE: S
  #cp_name:: Symbol           : 呼び口名
  #cell_or_t:: Celltype|Cell  : celltype の require の右辺で指定されたセルタイプまたはセル
  #port::  Port               : celltype の Port オブジェクト
  def set_require_join( cp_name, cell_or_ct, port )

    # set_require_join は2度呼び出される
    # 2度目は post コードを生成した後       #####  いったん見合わせ（重複エラーを見逃す）
    # if @require_joined_list[ cp_name ] then
    #   return
    # else
    #   @require_joined_list[ cp_name ] = true
    # end

    dbgPrint "set_require_join: #{@name}.#{cp_name} = #{cell_or_ct.get_name}.#{port.get_name}\n"

    if cell_or_ct.instance_of? Celltype then
      # print "DOMAIN: not considered\n"
      cell = cell_or_ct.get_singleton_cell @region
      if cell == nil then
        cdl_error( "S1025 not found reachable cell for require \'$1\' in celltype \'$2\'" , port.get_name, cell_or_ct.get_name )
        return
      end
    else
      # require: cell で指定
      cell = cell_or_ct
      if @region.distance( cell.get_region ) == nil then
        cdl_error( "S1026 required cell \'$1\' not reachable" , cell.get_name )
      end
    end

    if @join_list.get_item( cp_name ) then
      cdl_warning( "W1003 $1 : require call port overridden in $2" , cp_name, @name )
    else
      # require の join を生成(呼び口の結合)
#      rhs = Expression.new( [ :OP_DOT, [ :IDENTIFIER, Token.new( cell.get_name, nil, nil, nil ) ],
      nsp = NamespacePath.new( cell.get_name, false, cell.get_namespace )
      nsp.set_locale @locale
      rhs = Expression.new( [ :OP_DOT, [ :IDENTIFIER, nsp ],
                              Token.new( port.get_name, nil, nil, nil ) ], @locale )   #1
      join = Join.new( cp_name, nil, rhs, @locale )
      self.new_join( join )

      join.set_definition( @celltype.find(join.get_name) )
    end
  end

  #=== Cell# Join の definition の設定とチェック
  # STAGE: S
  # 結合の意味チェック
  def set_definition_join
    return if @celltype == nil    # 既にエラー：打ち切る
    return if @b_defined == false # プロトタイプ宣言のみ
    return if @b_checked == true  # 既に設定（チェック）済み

    dbgPrint "set_definition_join in #{@name}\n"

    # relay allocator をたどって再入しないよう、先頭で @b_checked を true にする
    @b_checked = true

    if ! @f_cloned then
      check_restrict_list
      
      # compoiste セルのクローンされたものは、set_definition 不要
      # 元の join は既に definition されている
      # 元のセルにおいて、代入チェックされているので、二重にチェック(through適用)されてしまう
      @join_list.get_items.each{ |join|
        dbgPrint " set_definition_join: checking #{@name}.#{join.get_name}\n"
        if join.get_array_member then
          port = @celltype.find(join.get_name)
          join.get_array_member2.each { |am|
            if am == nil then   # 未結合の場合、エラーチェックは check_join
              if port && ! port.is_optional? then
                # テスト用にエラーメッセージ出力
                # cdl_error( "TEMPORAL set_definition_join: uninitialized array member"  )
              end
              next
            end
            am.set_definition( port )
          }
        else
          dbgPrint "set_definition_join: #{@name}.#{join.get_name} celltype=#{@celltype.get_name}\n"
          join.set_definition( @celltype.find(join.get_name) )
        end
      }
    end

    # リレー join は through プラグイン生成後にしかできない
    # through 後に結合先が入れ替えられる 
    create_relay_allocator_join

    # composite セルの展開
    if ! @in_composite && ! @f_cloned && @celltype.instance_of?( CompositeCelltype ) then
      # composite セルタイプ内の composite は展開しない
      # compoiste セル展開中の composite は展開しない (CompositeCelltype::expand 内で再帰的に expnad)
      expand
    end
  end

  #=== Cell# composite セルの展開
  # このセルが composite セルタイプ
  def expand

    #debug
    dbgPrint "=====    expanding   #{@name}     =====\n"

    # composite celltype の cell を展開
    @cell_list, @cell_list2 = @celltype.expand( @name, @global_name, @NamespacePath, @join_list, @region, @plugin, @locale )

    # プロトタイプが参照されている場合、子も参照されていることにする
    if @f_ref then
      dbgPrint "expand: set_f_ref\n"
      set_f_ref
    end
  end

  #=== Cell#内部セルの受け口添数最大値を設定
  def set_max_entry_port_inner_cell
    if @cell_list == nil then
      return
    end

    dbgPrint "set_max_entry_port_inner_cell name=#{@name} entry_array_max_subscript.len=#{@entry_array_max_subscript.length}\n"

    # プロトタイプ宣言で設定されていたものを反映する
    @entry_array_max_subscript.each{ |port,name|
      dbgPrint "set_entry_inner_port_max_subscript( #{port}, #{name} )\n"
      set_entry_inner_port_max_subscript( port, name )
    }
  end

  #=== Cell#restrict を追加
  def add_restrict( entry_name, func_name, region_name_list )
    if @restrict_list[ entry_name ] == nil then
      @restrict_list[ entry_name ] = {}
      @restrict_list2[ entry_name ] = {}
    end
    if @restrict_list[ entry_name ][ func_name ] == nil then
      @restrict_list[ entry_name ][ func_name ] = []
      @restrict_list2[ entry_name ][ func_name ] = []
    end
    region_name_list.each { |rp|
      @restrict_list[ entry_name ][ func_name ] << rp
      # p "Class: " + rp.to_s
      obj = Namespace.find rp
      if ( obj.kind_of? Region ) then
        @restrict_list2[ entry_name ][ func_name ] << obj.get_domain_root
      else
        cdl_error( "S9999 $1 not found or not region", rp.to_s )
      end
    }
  end

  #=== Cell#check_restrict_list
  def check_restrict_list
    # p "check_restrict_list"
    @restrict_list.each{ |entry_name, func_hash|
      func_hash.each{ |func_name, region_list|
        region_list.each{ |rp|
          obj = Namespace.find rp
          if ( obj.kind_of? Region ) then
            if obj.get_domain_root != @region.get_domain_root then
            else
              cdl_info( "I9999 $1: restrict calling domain to $2, which is same domain as the cell locates", @name, rp.to_s )
              # restrict を同じドメインを指定してもよいこととする (HRP3)
              # KernelDoamin 内のセルに対し、KernelDomain に restrict している場合、
              # 無所属経由で結合されているが、KernelDomain から呼出すことを想定した許可
            end
          else
            cdl_error( "S9999 $1 not region", rp.to_s )
          end
        }
      }
    }
  end

  #=== Cell#callable?
  def callable?( callee_cell, entry_name, func_name )
    # p "callable? #{@name}"
    res = callee_cell.callable_from?( entry_name, func_name, self )
    dbgPrint "callable? #{callee_cell.get_namespace_path}.#{entry_name}.#{func_name} from #{@NamespacePath} is #{res}\n"
    return res
  end

  #=== Cell#callable_from? (private)
  def callable_from?( entry_name, func_name, caller_cell )
    @b_restrict_referenced = true
    if @restrict_list.length == 0 then
      return true
    end

    dr = caller_cell.get_region.get_domain_root
    if @restrict_list[entry_name] then
      if @restrict_list[entry_name][func_name] then
        @restrict_list2[entry_name][func_name].each{ |region|
          if dr == region then
            return true
          end
        }
      elsif @restrict_list[entry_name][nil] then
        @restrict_list2[entry_name][nil].each{ |region|
          if dr == region then
            return true
          end
        }
      else
        return false
      end
    else
      return false
    end
  end

  #=== Cell#get_callable_regions( entry_name, func_name )
  # func_name=nil の場合、entry_name の可否をチェックする
  # nil が返る場合、制限されていないことを意味する
  # 返された、受け口、受け口関数へ
  def get_restricted_regions( entry_name, func_name )
    # p "get_restricted_regions #{@name}"
    @b_restrict_referenced = true
    if @restrict_list[entry_name] then
      if @restrict_list[entry_name][func_name] then
        return @restrict_list2[entry_name][func_name]
      else
        return @restrict_list2[entry_name][nil]
      end
    end
    return nil
  end

  #=== Cell#has_ineffective_restrict_specifier
  # restrict 指定子が指定されていて、参照されていない場合 true
  # 参照は、HRPSVCPlugin のみ
  def has_ineffective_restrict_specifier
    if @restrict_list.length != 0 && @b_restrict_referenced == false then
      return true
    else
      return false
    end
  end

  def show_tree( indent )
    indent.times { print "  " }
    puts "Cell: name: #{@name} in_composite: #{@in_composite} def: #{@b_defined} ref: #{@f_ref} cloned: #{@f_cloned}"
    (indent+1).times { print "  " }
    puts "Cell locale: #{@name}@#{@locale[0]}##{@locale[1]}"
    (indent+1).times { print "  " }
    puts "id: #{@id}  global_name: #{@global_name}  region: #{@region.get_name} plugin: #{@plugin.class.name} #{self}"
    (indent+1).times { print "  " }
    puts "namespace_path: #{@NamespacePath}"

    if @celltype then
      (indent+1).times { print "  " }
      puts "celltype: #{@celltype.get_name}"
    end
    @join_list.show_tree( indent + 1 )
    @entry_array_max_subscript.each{ |port, num|
      (indent+1).times { print "  " }
      puts "entry array #{port.get_name}: max subscript=#{num}"
    }
    if @cell_list then   # ここで @cell_list が nil なのは Bug
      (indent+1).times { print "  " }
      puts "cloned cell list:"
      @cell_list.each { |n,c|
        (indent+2).times { print "  " }
        puts "inner cell : #{n} = #{c.get_name}"
      }
    end
    if @compositecelltypejoin_list then
      @compositecelltypejoin_list.get_items.each{ |cj|
        cj.show_tree( indent+1 )
      }
    end
    if @alloc_list.length > 0 then
      (indent+1).times { print "  " }
      puts "allocator list: "
      @alloc_list.each { |a|
        cp_name = :"#{a[0+1]}_#{a[2+1]}_#{a[3+1]}"
        if a[1+1] then
          # subscript = "[#{a[1+1].eval_const nil}]"
          subscript = "[#{a[1+1]}]"
        else
          subscript = ""
        end
        # アロケータ呼び口の結合を生成
        (indent+2).times { print "  " }
        puts "#{cp_name}#{subscript} = #{a[4+1]}"
      }
    end
    @referenced_port_list.each{ |port,count|
      (indent+1).times { print "  " }
      puts( "#{port.get_name} : #{count} times referenced" )
    }
  end

end

