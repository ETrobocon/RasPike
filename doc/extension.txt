
		TOPPERS/ASP3カーネル
		機能拡張・チューニングガイド

		対応バージョン: Release 3.2
		最終更新: 2016年3月31日

このドキュメントは，TOPPERS/ASPカーネル3を，機能拡張・チューニングする
ための方法（またはヒント）を説明するものである．

----------------------------------------------------------------------
 TOPPERS/ASP Kernel
     Toyohashi Open Platform for Embedded Real-Time Systems/
     Advanced Standard Profile Kernel

 Copyright (C) 2005-2016 by Embedded and Real-Time Systems Laboratory
             Graduate School of Information Science, Nagoya Univ., JAPAN
 
 上記著作権者は，以下の(1)〜(4)の条件を満たす場合に限り，本ソフトウェ
 ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
 変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
 (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
     権表示，この利用条件および下記の無保証規定が，そのままの形でソー
     スコード中に含まれていること．
 (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
     用できる形で再配布する場合には，再配布に伴うドキュメント（利用
     者マニュアルなど）に，上記の著作権表示，この利用条件および下記
     の無保証規定を掲載すること．
 (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
     用できない形で再配布する場合には，次のいずれかの条件を満たすこ
     と．
   (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
       作権表示，この利用条件および下記の無保証規定を掲載すること．
   (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
       報告すること．
 (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
     害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
     また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
     由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
     免責すること．
 
 本ソフトウェアは，無保証で提供されているものである．上記著作権者お
 よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
 に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
 アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
 の責任を負わない．
 
 $Id: extension.txt 800 2017-07-19 23:34:23Z ertl-hiro $
----------------------------------------------------------------------

○目次

・エラーチェックの省略
・特殊目的のレジスタの扱い
・拡張パッケージの使い方
	- ドリフト調整機能拡張パッケージ
	- メッセージバッファ機能拡張パッケージ
	- オーバランハンドラ機能拡張パッケージ
	- タスク優先度拡張パッケージ
	- 制約タスク拡張パッケージ
	- サブ優先度機能拡張パッケージ
	- 動的生成機能拡張パッケージ
・CPU例外ハンドラの直接呼出し
	- TA_DIRECT属性の導入
	- ターゲット依存部の修正箇所


○エラーチェックの省略

サービスコールのオーバヘッドを削減するために，静的なエラーのチェックを
省略する方法がある．ASP3カーネルにおいては，静的なエラーのチェックはす
べてCHECKマクロを用いて行っているため，kernel/check.h中のCHECKマクロを
変更することで，静的なエラーのチェックを省略することができる．

例えば，オブジェクトIDのチェックを省略したい場合には，CHECK_IDマクロの
定義を，次のように変更すればよい．

#define CHECK_ID(exp)			((void)(exp))

このマクロの定義を空にする方法もあるが，パラメータに副作用のある式が書
かれている可能性を考えると（副作用のある式は書くべきではないが，書かれ
ているコードが入ってくる可能性が全くないとは言えない），上の定義の方が
安全である．副作用のない式であれば，最適化によって削除することができる
ため，実行時効率には影響がないと期待できる．ただし，最適化によって削除
されない場合には，副作用のある式が書かれていないことを確認した上で，マ
クロの定義を空にしてもよい．

もう少し小さい粒度でエラーチェックを省略したい場合には，kernel/check.h
中のVALIDマクロを変更する方法がある．例えば，タスクIDの中でチェックを省
略したい場合には，VALID_TSKIDマクロの定義を，次のように変更すればよい．

#define VALID_TSKID(tskid)		(true)


○特殊目的のレジスタの扱い

FPUレジスタやDSPレジスタなどの特殊目的のレジスタ（以下，特殊レジスタ）
を持つプロセッサでは，レジスタの扱いについて大きく次の3つの方法が考えら
れる．

(1) 特殊レジスタをタスクのコンテキストに含めない

1つのタスクのみが特殊レジスタを使用する場合には，特殊レジスタをタスクの
コンテキストに含める必要がなく，カーネルで管理する必要がない．

(2) 特殊レジスタをタスクのコンテキストに含める

複数のタスクが特殊レジスタを使用する場合には，特殊レジスタをタスクのコ
ンテキストに含める方法が最も単純である．そのためには，タスクディスパッ
チャと割込みハンドラ/CPU例外ハンドラの出入口で，特殊レジスタを保存/復帰
するコードを追加する必要がある．実際の保存/復帰場所は，スクラッチレジス
タとそれ以外のレジスタで異なるため，注意が必要である．

(3) 特殊レジスタをコンテキストに含めるかどうかをタスク毎に指定する

特殊レジスタを使用するタスクと使用しないタスクがある場合で，すべてのタ
スクのコンテキストに特殊レジスタを含める方法ではオーバヘッドが問題にな
る場合には，特殊レジスタをコンテキストに含めるかどうかをタスク毎に指定
する方法が有力である．これを実現する方法は次の通りである．

まず，特殊レジスタをコンテキストに含めるかどうかを指定するタスク属性を
設ける．例えば，FPUレジスタであれば，タスク属性にTA_FPUを設ける．タスク
ディスパッチャでは，タスク属性を見て，その属性が設定されていれば特殊レ
ジスタを保存/復帰する．

ハードウェア的に特殊レジスタがディスエーブルできる場合には，その属性が
設定されていないタスクに切り換える時に特殊レジスタをディスエーブルする
と，誤って特殊レジスタを使った場合を検出できる．

さらに，割込みハンドラ（ISR，周期ハンドラ，アラームハンドラを含む）や
CPU例外ハンドラで特殊レジスタを使用する場合には，これらの処理単位にも
特殊レジスタを使用するかどうかの属性を設ける方法が考えられる．

ここで，タスク（または他の処理単位）が特殊レジスタを使用するかどうかは，
コンパイラやライブラリに依存する場合があるため，注意が必要である．例え
ば，浮動小数点演算を含まないプログラムであっても，コンパイラがその方が
性能が高いと判断すれば，浮動小数点命令を生成する場合がある．


○拡張パッケージの使い方

ASP3カーネルでは，いくつかの拡張機能を実装するために，拡張パッケージを
サポートしている．拡張パッケージは，extensionディレクトリに置いてある．

拡張パッケージを使用する場合には，UNIXであれば，ASP3カーネルのソースファ
イルのトップディレクトリで，

	% cp -r extension/<拡張パッケージのディレクトリ名>/* .

を実行する．この時，元の（拡張前の）ソースファイルは上書きされてしまう
ため，拡張しないカーネルも使用したい場合には，別のディレクトリにソース
ファイルを展開して，上のコマンドを実行すること．

複数の拡張パッケージを使うことは考慮していないが，拡張パッケージの組み
合わせによっては，手作業により複数の拡張パッケージをマージすることは可
能である．

●ドリフト調整機能拡張パッケージ

ドリフト調整機能拡張パッケージは，ドリフトの調整機能を追加するための拡
張パッケージである．ドリフト調整機能拡張パッケージは，extension/driftディ
レクトリに置いてある．

ドリフト調整機能拡張パッケージでは，TOPPERS_SUPPORT_DRIFTがkernel.h中で
定義されているので，これを用いてドリフト調整機能を使用できるかどうかを
判別することができる．

ドリフト調整機能拡張パッケージにより追加されるサービスコール

	ER ercd = set_dft(int32_t drift)

●メッセージバッファ機能拡張パッケージ

メッセージバッファ機能拡張パッケージは，メッセージバッファ機能を追加す
るための拡張パッケージである．メッセージバッファ機能拡張パッケージは，
extension/messagebufディレクトリに置いてある．

メッセージバッファ機能拡張パッケージでは，TOPPERS_SUPPORT_MESSAGEBUFが
kernel.h中で定義されているので，これを用いてメッセージバッファ機能を使
用できるかどうかを判別することができる．

メッセージバッファ機能拡張パッケージでは，メッセージバッファに対する送
信待ち状態のタスクが複数待ち解除される場合がある．この場合，サービスコー
ルの実行時間およびカーネル内での割込み禁止時間が，待ち解除されるタスク
の数の数のオーダで長くなるので注意が必要である．メッセージバッファに対
する送信待ち状態のタスクが複数待ち解除されるのは，メッセージバッファ管
理領域に格納されたメッセージが受信された結果，管理領域に空き領域が生じ
た場合に加えて，送信待ち行列の先頭につながれているタスクの強制終了や待
ち解除の場合にも生じる．

メッセージバッファ機能拡張パッケージにより追加されるサービスコール

	ER ercd = snd_mbf(ID mbfid, const void *msg, uint_t msgsz)
	ER ercd = psnd_mbf(ID mbfid, const void *msg, uint_t msgsz)
	ER ercd = tsnd_mbf(ID mbfid, const void *msg, uint_t msgsz, TMO tmout)
	ER_UINT msgsz = rcv_mbf(ID mbfid, void *msg)
	ER_UINT msgsz = prcv_mbf(ID mbfid, void *msg)
	ER_UINT msgsz = trcv_mbf(ID mbfid, void *msg, TMO tmout)
	ER ercd = ini_mbf(ID mbfid)
	ER ercd = ref_mbf(ID mbfid, T_RMBF *pk_rmbf)

メッセージバッファ機能拡張パッケージにより追加される静的API

	CRE_MBF(ID mbfid, { ATR mbfatr, uint_t maxmsz, size_t mbfsz, void *mbfmb })

メッセージバッファ機能拡張パッケージでは，memcpyを使用しているため，標
準Cライブラリが必要である．標準Cライブラリを用意する代わりに，memcpy関
数のみを自分で用意してもよい．

●オーバランハンドラ機能拡張パッケージ

オーバランハンドラ機能拡張パッケージは，オーバランハンドラ機能を追加す
るための拡張パッケージである．ただし，この拡張パッケージを使うためには，
ターゲット依存部が対応している必要がある．オーバランハンドラ機能拡張パッ
ケージは，extension/ovrhdrディレクトリに置いてある．

オーバランハンドラ機能拡張パッケージで，ターゲット依存部が拡張パッケー
ジに対応している場合には，TOPPERS_SUPPORT_OVRHDRがkernel.h中で定義され
るので，これを用いてオーバランタイマ機能が使用できるかどうかを判別する
ことができる．

オーバランハンドラ機能拡張パッケージにより追加されるサービスコール

	ER ercd = sta_ovr(ID tskid, PRCTIM ovrtim)
	ER ercd = stp_ovr(ID tskid)
	ER ercd = ref_ovr(ID tskid, T_ROVR *pk_rovr)

オーバランハンドラ機能拡張パッケージにより追加される静的API

	DEF_OVR({ ATR ovratr, OVRHDR ovrhdr })

●タスク優先度拡張パッケージ

タスク優先度拡張パッケージは，タスク優先度を最大256段階に拡張するための
拡張パッケージである．この拡張パッケージは，タスク優先度に加えて，デー
タ優先度，メッセージ優先度，割込みサービスルーチン優先度も256段階に拡張
する．タスク優先度拡張パッケージは，extension/pri_levelディレクトリに置
いてある．

タスク優先度拡張パッケージでは，TOPPERS_SUPPORT_PRI_LEVELがkernel.h中で
定義されているので，これを用いてタスク優先度の範囲が拡張されているかど
うかを判別することができる．

●制約タスク拡張パッケージ

制約タスク拡張パッケージは，制約タスクの機能を追加するための拡張パッケー
ジである．制約タスク拡張パッケージは，extension/rstr_taskディレクトリに
置いてある．

制約タスク拡張パッケージでは，TOPPERS_SUPPORT_RSTR_TASKがkernel.h中で定
義されているので，これを用いて制約タスクの機能が使用できるかどうかを判
別することができる．

●サブ優先度機能拡張パッケージ

サブ優先度機能拡張パッケージは，サブ優先度機能を追加するための拡張パッ
ケージである．サブ優先度機能拡張パッケージは，extension/subprioディレク
トリに置いてある．

サブ優先度機能拡張パッケージでは，TOPPERS_SUPPORT_SUBPRIOがkernel.h中で
定義されているので，これを用いてサブ優先度機能が使用できるかどうかを判
別することができる．

サブ優先度機能拡張パッケージにより追加されるサービスコール

	ER ercd = chg_spr(ID tskid, uint_t subpri)

サブ優先度機能拡張パッケージにより追加されるサービスコール

	ENA_SPR(PRI tskpri)

●動的生成機能拡張パッケージ

動的生成機能拡張パッケージは，オブジェクトの動的生成機能を追加するため
の拡張パッケージである．TOPPERS第3世代カーネル（ITRON系）統合仕様書に規
定された以下のオブジェクト生成／削除のためのサービスコール，割付け可能
なID番号の数を指定する静的APIに加えて，カーネルが割り付けるメモリ領域を
設定する静的API DEF_KMMを実装している．動的生成機能拡張パッケージは，
extension/dcreディレクトリに置いてある．

ただし，カーネル内での動的メモリ管理に関しては，ターゲット非依存部では，
メモリ領域を先頭から順に割り当て，解放されたメモリ領域を再利用しないメ
モリ管理モジュールのみを実装している．本格的な動的メモリ管理を行いたい
場合には，ターゲット依存部またはユーザ側で，そのための関数を用意する必
要がある．用意する関数等については，「TOPPERS/ASP3カーネル ターゲット依
存部 ポーティングガイド」の「6.15 動的メモリ管理」の節を参照すること．

動的生成機能拡張パッケージでは，TOPPERS_SUPPORT_DYNAMIC_CREがkernel.h中
で定義されているので，これを用いて動的生成機能が使用できるかどうかを判
別することができる．

動的生成機能拡張パッケージにより追加されるサービスコール

	ER_ID tskid = acre_tsk(const T_CTSK *pk_ctsk)
	ER ercd = del_tsk(ID tskid)
	ER_ID semid = acre_sem(const T_CSEM *pk_csem)
	ER ercd = del_sem(ID semid)
	ER_ID flgid = acre_flg(const T_CFLG *pk_cflg)
	ER ercd = del_flg(ID flgid)
	ER_ID dtqid = acre_dtq(const T_CDTQ *pk_cdtq)
	ER ercd = del_dtq(ID dtqid)
	ER_ID pdqid = acre_pdq(const T_CPDQ *pk_cpdq)
	ER ercd = del_pdq(ID pdqid)
	ER_ID mtxid = acre_mtx(const T_CMTX *pk_cmtx)
	ER ercd = del_mtx(ID mtxid)
	ER_ID mpfid = acre_mpf(const T_CMPF *pk_cmpf)
	ER ercd = del_mpf(ID mpfid)
	ER_ID cycid = acre_cyc(const T_CCYC *pk_ccyc)
	ER ercd = del_cyc(ID cycid)
	ER_ID almid = acre_alm(const T_CALM *pk_calm)
	ER ercd = del_alm(ID almid)
	ER_ID isrid = acre_isr(const T_CISR *pk_cisr)
	ER ercd = del_isr(ID isrid)

動的生成機能拡張パッケージにより追加される静的API

	AID_TSK(uint_t notsk)
	AID_SEM(uint_t nosem)
	AID_FLG(uint_t noflg)
	AID_DTQ(uint_t nodtq)
	AID_PDQ(uint_t nopdq)
	AID_MTX(uint_t nomtx)
	AID_MPF(uint_t nompf)
	AID_CYC(uint_t nocyc)
	AID_ALM(uint_t noalm)
	AID_ISR(uint_t noisr)
	DEF_KMM({ SIZE kmmsz, STK_T *kmm })

動的生成機能拡張パッケージでは，del_yyyで削除するオブジェクトに対する待
ち状態のタスクが複数あると，del_yyyにより，複数のタスクが待ち解除される．
この場合，サービスコールの実行時間およびカーネル内での割込み禁止時間が，
待ち解除されるタスクの数のオーダで長くなるので注意が必要である．

----------------------------------------------------------------------
DEF_KMM		カーネルが割り付けるメモリ領域の設定〔SD〕

【静的API】
	DEF_KMM({ SIZE kmmsz, STK_T *kmm })
	※ kmmの記述は省略することができる．

【パラメータ】
　＊カーネルが割り付けるメモリ領域の設定情報
	SIZE		kmmsz		カーネルが割り付けるメモリ領域のサイズ（バイト数）
	STK_T		kmm			カーネルが割り付けるメモリ領域の先頭番地

【エラーコード】
	E_PAR		パラメータエラー
				・kmmszが0以下
				・その他の条件については機能の項を参照
	E_OBJ		オブジェクト状態エラー
				・カーネルが割り付けるメモリ領域が設定済み

【機能】

各パラメータで指定したカーネルが割り付けるメモリ領域の設定情報に従って，
カーネルが割り付けるメモリ領域を設定する．

kmmszは整数定数式パラメータ，kmmは一般定数式パラメータである．

kmmの記述を省略するか，kmmをNULLとした場合，kmmszで指定したサイズのメモ
リ領域を，コンフィギュレータが確保する．kmmszにターゲット定義の制約に合
致しないサイズを指定した時には，ターゲット定義の制約に合致するようにサ
イズを大きい方に丸めて確保する．

カーネルが割り付けるメモリ領域をアプリケーションで確保する場合には，
kmmszで指定したサイズのメモリ領域を確保し，kmmにその先頭番地を指定する．

DEF_KMMによりカーネルが割り付けるメモリ領域を設定しない場合，カーネルが
割り付けるメモリ領域は確保されない．

kmmやkmmszにターゲット定義の制約に合致しない先頭番地やサイズを指定した
時には，E_PARエラーとなる．
----------------------------------------------------------------------


○CPU例外ハンドラの直接呼出し

CPU例外ハンドラの出入口処理は，CPU例外が発生しないように実装しなければ
ならないが，これが防げないターゲットにおいては，CPU例外ハンドラの出入口
処理を経由せずに，アプリケーションが用意したCPU例外ハンドラを直接実行す
る方法を用意するのが望ましい．これを，CPU例外ハンドラの直接呼出しと呼ぶ．

ここでは，ハードウェアでベクタテーブルを持つプロセッサにおいて，ターゲッ
ト非依存部に含まれる標準のCPU例外管理機能の初期化処理を用いている場合
（OMIT_INITILIZE_EXCEPTIONをマクロ定義していない場合）に，ターゲット依
存部のみの修正により，CPU例外ハンドラの直接呼出しの機能を追加する方法に
ついて説明する．

●TA_DIRECT属性の導入

CPU例外ハンドラの直接呼出しを指定するために，CPU例外ハンドラ属性に，
TA_DIRECT属性を導入する．

●ターゲット依存部の修正箇所

TA_DIRECTの値を，target_kernel.h（または，そこからインクルードされるファ
イル）で定義し，その値をコンフィギュレータが取り出せるように，
target_def.csv（または，それに代わるファイル）に次の行を追加する．

TA_DIRECT,TA_DIRECT

次に，target.tf（または，そこからインクルードされるファイル）で，
TARGET_EXCATRに設定される値に，TA_DIRECTを追加する．例えば，他のターゲッ
ト依存のCPU例外ハンドラ属性がない場合には，次のように設定する．

$TARGET_EXCATR = TA_DIRECT$

次に，OMIT_INITILIZE_EXCEPTIONをマクロ定義して，CPU例外ハンドラの出入口
処理を生成するための記述とCPU例外ハンドラ初期化ブロックの標準の定義が生
成されるのを抑止し，それによって抑止される部分をtarget.tfにコピーした上
で，以下の修正を加える．

CPU例外ハンドラの出入口処理を生成するための記述（EXCHDR_ENTRYのリスト）
を生成する部分は，次のように修正する．

----------------------------------------
$FOREACH excno EXC.ORDER_LIST$
	$IF (EXC.EXCATR[excno] & TA_DIRECT) == 0$
		EXCHDR_ENTRY($EXC.EXCNO[excno]$, $+EXC.EXCNO[excno]$,$SPC$
											$EXC.EXCHDR[excno]$)$NL$
	$END$
$END$$NL$
----------------------------------------

また，CPU例外ハンドラ初期化ブロックの定義を生成する部分は，次のように修
正する．

----------------------------------------
$IF LENGTH(EXC.ORDER_LIST)$
	const EXCINIB _kernel_excinib_table[TNUM_DEF_EXCNO] = {$NL$
	$JOINEACH excno EXC.ORDER_LIST ",\n"$
		$IF (EXC.EXCATR[excno] & TA_DIRECT) == 0$
			$TAB${$SPC$
				($EXC.EXCNO[excno]$),$SPC$
				($EXC.EXCATR[excno]$),$SPC$
				(FP)(EXC_ENTRY($EXC.EXCNO[excno]$, $EXC.EXCHDR[excno]$))$SPC$
			}
		$ELSE$
			$TAB${$SPC$
				($EXC.EXCNO[excno]$),$SPC$
				($EXC.EXCATR[excno]$),$SPC$
				(FP)($EXC.EXCHDR[excno]$)
			}
		$END$$NL$
	$END$
	};$NL$
$ELSE$
	TOPPERS_EMPTY_LABEL(const EXCINIB, _kernel_excinib_table);$NL$
$END$$NL$
----------------------------------------

以上
